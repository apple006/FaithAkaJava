# Effective Java

代码组织规则：

`com.nickchen.N{x}`, `{x}` 表示的是书中对应的条目数。如书中第三条，就对应 `N{03}`


## 简写条目体会

- 第一条： 多用静态方法工厂 > 有名称标识 | 可控制生成的类（单例还是子类）
- 第二条： 多构造器参数要灵活使用构建器。（Builder模式） > 自由组合需要构造参数，对象一步创建
- 第三条： 单例模式使用私有构造器或者枚举类型强化（推荐枚举类型）
- 第四条： 私有构造器强化不可实例化的能力。 > 但也不能被子类化了
- 第五条： 减少不必要对象创建，小心自动拆装箱，强调对象的复用
- 第六条： 及时消除过期的对象引用。 > 集合类型中存储的对象，删除时及时清理 | ThreadLocal 等 map 类对象，key 与 value 及时清理 | 监听器注册注销
- 第七条： 避免使用 finalizer 方法
- 第八条： 覆盖 equals 方法的规约。 > 自反性 | 对称性 | 传递性 | 一致性
- 第九条： 覆盖 equals 总要覆盖 hashcode。 > [hashcode通用计算方法](https://github.com/nickChenyx/FaithAkaJava/blob/master/effectivejava2th/src/main/java/com/nickchen/N09/OverrideHashCode.java)
- 第十条： 始终覆盖 toString 保持对象输出的可读性。
- 第十一条： 谨慎地覆盖 clone
- 第十二条： 考虑实现 Comparable 接口，对象具有可比较性。> 这里注意 TreeSet 是通过 compareTo 来判断对象是否相同 | (x.compareTo(y) == 0) == (x.equals(y)) 最好成立，否则要注明两者不同
- 第十三条： 使类和成员的可访问性最小 > 正确使用访问修饰符
- 第十四条： 公有类中的公有域尽量不要直接访问 > 设置 setter getter
- 第十五条： 使可变性最小化 > 不可变类的实现规则：不要有 mutator | 不被扩展 | 域都是final且私有 | 确保对于任何可变组件的互斥访问
- 第十六条： 组合优先于继承
- 第十七条： 要么为继承而设计，并提供文档，要么就禁止继承
- 第十八条： 接口优于抽象类
- 第十九条： 接口只用于定义类型 > 接口用来定义常量是不好的 | 使用枚举或者不可实例化的类来定义常量
- 第二十条： 类层次优于标签类 > 子类化优于使用 tag 域标识对象
- 第二十一条： 用函数对象表示策略 > = =。。。咋说呢，传入一个接口的具体实现类再调用固定方法。
- 第二十二条： 优先考虑静态成员类 > static class 静态成员类不会保留外围类的引用
- 第二十三条： 不要在新代码中使用原生态类型 > 就是统一使用泛型
- 第二十四条： 消除非受检警告 > 泛型使用中的 unchecked warning，@SuppressWarnings("unchecked")
- 第二十五条： 列表优先于数组 > 第一反应是用列表代替数组
- 第二十六条： 优先考虑泛型 > 泛型带来的类型安全
- 第二十七条： 优先考虑泛型方法 > 方便方法的复用，返回值也是泛型
- 第二十八条： 利用有限制通配符来提升API的灵活性
- 第二十九条： 优先考虑类型安全的异构容器 > 一个 map 所有的键都是不同类型的（用 class作为key），就称为异构容器；请求String不会返回其他类型，就称为类型安全。

---

- 第五十七条： 只针对异常的情况才使用异常 > 以上永远不应该用于正常的 *控制流* | 状态相关的方法参考 hasNext 和 next 的设计
- 第五十八条： 对可恢复的情况使用受检异常，对编程错误使用运行时异常 > 前提违例：使用API的客户没有遵守API规范建立的约定，抛出运行时异常。
- 第五十九条： 避免不必要地使用受检的异常
- 第六十条： 优先使用标准异常 > IllegalArgumentException | IllegalStateException | NullPointException | UnSupportedOperationException
- 第六十一条： 抛出与抽象相对应的异常 > 高层异常实现需要捕获底层的一场实现，并包装好更多的现场情况再抛出。
- 第六十二条： 每个方法抛出的异常都要有文档 > `@throws` 标记抛出未受检异常，但不要使用 `throws` 关键字将未受检的异常包含在方法的声明中。
- 第六十三条： 在细节消息中包含能捕获失败的信息
- 第六十四条： 努力使失败保持原子性 > 即使发生了异常，不要让异常影响到当前状态 | 在执行操作之前先检查参数有效性 | 写一段recovery code
- 第六十五条： 不要忽略异常 > try-catch 了异常然是 ignore，这是不合理的。