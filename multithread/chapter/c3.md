## Chapter3

### InheritableThreadLocal 1&2

* InheritableThreadLocal 提供可供后一个类继承上一个类 ThreadLocal 值的方法。
* initialValue() 生成初始值
* childValue() 可以定义 *后一个* 线程的值

### join_sleep 1&2

* sleep() 并不会释放锁，等待线程没有机会获得锁
* join() 会释放锁

```java
            synchronized (b){
                b.start();
                b.join(); // 会释放锁，这时候另一个需要对象b锁的线程得以运行
                System.out.println("b join finish");
                for (int i = 0; i < Integer.MAX_VALUE; i++) {
                    String newString = new String();
                    Math.random();
                }
            }
```

### joinException

* 调用了 `join()` 的线程在等待 `join()` 的线程执行完前被 `interrupt()` 会抛出 `java.lang.InterruptedException` 异常

```java
            // 线程B
            ThreadA a = new ThreadA();
            a.start();
            a.join();

            // 线程C
            threadB.interrupt();
```


### joinLong

* `join(long delay)` 可以指定阻塞超时时间，和 `sleep(long delay)` 的区别就是同步，`sleep(long delay)` 不释放锁！


### joinMoreTest

* 这是一个很奇特的实验案例，按理说线程b执行了 `join(2000)`，之后 main 线程会被阻塞。但是却出现了线程b已经开始执行了，而main却 **无延时**地依旧打印出来了；还有线程b尚未执行，main就打印出来了。

```java
            ThreadB b = new ThreadB();
            ThreadA a = new ThreadA(b);
            a.start();
            b.start();
            b.join(2000); // b.join() 不会出现这种问题
            System.out.println("   main end time="+System.currentTimeMillis());
            // 第一种打印结果 
            /**
            *a run begin time=1493969608961
            *a run end  time=1493969613961
            *    main end time=1493969613961
            *b run begin time=1493969613961
            *b run end  time=1493969618961
            **/
            // 第二种打印结果
            /**
            *a run begin time=1493969608961
            *a run end  time=1493969613961
            *b run begin time=1493969613961
            *    main end time=1493969613961
            *b run end  time=1493969618961
            **/
```



### p_c_allWait

* 生成者消费者模式出现假死情况，`notify()` 只随机唤醒一个线程，这时候对应多个生产者消费者的时候会出现假死，这时候要使用 `notifyAll()`

